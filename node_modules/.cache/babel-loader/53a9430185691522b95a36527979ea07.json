{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport { compose } from 'recompose';\nimport { withTheme } from 'styled-components';\nimport { normalizeColor, parseMetricToNum } from '../../utils';\nimport { StyledChart } from './StyledChart';\nimport { areNormalizedBoundsEquals, areNormalizedValuesEquals, normalizeBounds, normalizeValues } from './utils';\n\nvar renderBars = function renderBars(values, bounds, scale, height) {\n  return (values || []).map(function (valueArg, index) {\n    var label = valueArg.label,\n        onHover = valueArg.onHover,\n        value = valueArg.value,\n        rest = _objectWithoutPropertiesLoose(valueArg, [\"label\", \"onHover\", \"value\"]);\n\n    var key = \"p-\" + index;\n    var bottom = value.length === 2 ? bounds[1][0] : value[1];\n    var top = value.length === 2 ? value[1] : value[2];\n\n    if (top !== 0) {\n      var d = \"M \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (height - (bottom - bounds[1][0]) * scale[1])) + (\" L \" + (value[0] - bounds[0][0]) * scale[0] + \",\") + (\"\" + (height - (top - bounds[1][0]) * scale[1]));\n      var hoverProps;\n\n      if (onHover) {\n        hoverProps = {\n          onMouseOver: function onMouseOver() {\n            return onHover(true);\n          },\n          onMouseLeave: function onMouseLeave() {\n            return onHover(false);\n          }\n        };\n      }\n\n      return React.createElement(\"g\", {\n        key: key,\n        fill: \"none\"\n      }, React.createElement(\"title\", null, label), React.createElement(\"path\", _extends({\n        d: d\n      }, hoverProps, rest)));\n    }\n\n    return undefined;\n  });\n};\n\nvar renderLine = function renderLine(values, bounds, scale, height, _ref) {\n  var onClick = _ref.onClick,\n      onHover = _ref.onHover;\n  var d = '';\n  (values || []).forEach(function (_ref2, index) {\n    var value = _ref2.value;\n    d += (index ? ' L' : 'M') + \" \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (height - (value[1] - bounds[1][0]) * scale[1]));\n  });\n  var hoverProps;\n\n  if (onHover) {\n    hoverProps = {\n      onMouseOver: function onMouseOver() {\n        return onHover(true);\n      },\n      onMouseLeave: function onMouseLeave() {\n        return onHover(false);\n      }\n    };\n  }\n\n  var clickProps;\n\n  if (onClick) {\n    clickProps = {\n      onClick: onClick\n    };\n  }\n\n  return React.createElement(\"g\", {\n    fill: \"none\"\n  }, React.createElement(\"path\", _extends({\n    d: d\n  }, hoverProps, clickProps)));\n};\n\nvar renderArea = function renderArea(values, bounds, scale, height, _ref3) {\n  var color = _ref3.color,\n      onClick = _ref3.onClick,\n      onHover = _ref3.onHover,\n      theme = _ref3.theme;\n  var d = '';\n  (values || []).forEach(function (_ref4, index) {\n    var value = _ref4.value;\n    var top = value.length === 2 ? value[1] : value[2];\n    d += (!index ? 'M' : ' L') + \" \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (height - (top - bounds[1][0]) * scale[1]));\n  });\n  (values || []).reverse().forEach(function (_ref5) {\n    var value = _ref5.value;\n    var bottom = value.length === 2 ? bounds[1][0] : value[1];\n    d += \" L \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (height - (bottom - bounds[1][0]) * scale[1]));\n  });\n\n  if (d.length > 0) {\n    d += ' Z';\n  }\n\n  var hoverProps;\n\n  if (onHover) {\n    hoverProps = {\n      onMouseOver: function onMouseOver() {\n        return onHover(true);\n      },\n      onMouseLeave: function onMouseLeave() {\n        return onHover(false);\n      }\n    };\n  }\n\n  var clickProps;\n\n  if (onClick) {\n    clickProps = {\n      onClick: onClick\n    };\n  }\n\n  return React.createElement(\"g\", {\n    fill: normalizeColor(color.color || color, theme)\n  }, React.createElement(\"path\", _extends({\n    d: d\n  }, hoverProps, clickProps)));\n};\n\nvar Chart = function Chart(_ref6) {\n  var _ref6$color = _ref6.color,\n      color = _ref6$color === void 0 ? 'accent-1' : _ref6$color,\n      onClick = _ref6.onClick,\n      onHover = _ref6.onHover,\n      _ref6$overflow = _ref6.overflow,\n      overflow = _ref6$overflow === void 0 ? false : _ref6$overflow,\n      round = _ref6.round,\n      _ref6$size = _ref6.size,\n      size = _ref6$size === void 0 ? {\n    width: 'medium',\n    height: 'small'\n  } : _ref6$size,\n      theme = _ref6.theme,\n      _ref6$thickness = _ref6.thickness,\n      thickness = _ref6$thickness === void 0 ? 'medium' : _ref6$thickness,\n      _ref6$type = _ref6.type,\n      type = _ref6$type === void 0 ? 'bar' : _ref6$type,\n      values = _ref6.values,\n      bounds = _ref6.bounds,\n      rest = _objectWithoutPropertiesLoose(_ref6, [\"color\", \"onClick\", \"onHover\", \"overflow\", \"round\", \"size\", \"theme\", \"thickness\", \"type\", \"values\", \"bounds\"]);\n\n  var containerRef = useRef();\n\n  var _useState = useState({\n    width: 0,\n    height: 0\n  }),\n      containerState = _useState[0],\n      setContainerState = _useState[1];\n\n  var _useState2 = useState({\n    values: null,\n    bounds: null\n  }),\n      sizeState = _useState2[0],\n      setSizeState = _useState2[1];\n\n  var nextValues = normalizeValues(values);\n  var nextBounds = normalizeBounds(bounds, nextValues);\n\n  if (!sizeState.values || !areNormalizedValuesEquals(values, sizeState.values) && !areNormalizedValuesEquals(sizeState.values, nextValues) || !areNormalizedBoundsEquals(bounds, sizeState.bounds) && !areNormalizedBoundsEquals(sizeState.bounds, nextBounds)) {\n    setSizeState({\n      bounds: nextBounds,\n      values: nextValues\n    });\n  }\n\n  var onResize = function onResize() {\n    var containerNode = containerRef.current;\n\n    if (containerNode) {\n      var parentNode = containerNode.parentNode;\n\n      if (parentNode) {\n        var rect = parentNode.getBoundingClientRect();\n        setContainerState({\n          width: rect.width,\n          height: rect.height\n        });\n      }\n    }\n  };\n\n  useEffect(function () {\n    window.addEventListener('resize', onResize);\n    onResize();\n    return function cleanup() {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n  if (!sizeState.bounds || !sizeState.values) return null;\n  var sizeWidth = typeof size === 'string' ? size : size.width || 'medium';\n  var sizeHeight = typeof size === 'string' ? size : size.height || 'medium';\n  var width = sizeWidth === 'full' ? containerState.width : parseMetricToNum(theme.global.size[sizeWidth] || sizeWidth);\n  var height = sizeHeight === 'full' ? containerState.height : parseMetricToNum(theme.global.size[sizeHeight] || sizeHeight);\n  var strokeWidth = parseMetricToNum(theme.global.edgeSize[thickness]);\n  var scale = [width / (sizeState.bounds[0][1] - sizeState.bounds[0][0]), height / (sizeState.bounds[1][1] - sizeState.bounds[1][0])];\n  var viewBox = overflow ? \"0 0 \" + width + \" \" + height : \"-\" + strokeWidth / 2 + \" -\" + strokeWidth / 2 + \" \" + (width + strokeWidth) + \" \" + (height + strokeWidth);\n  var colorName = typeof color === 'object' ? color.color : color;\n  var opacity = color.opacity ? theme.global.opacity[color.opacity] : undefined;\n  var contents;\n\n  if (type === 'bar') {\n    contents = renderBars(sizeState.values, sizeState.bounds, scale, height);\n  } else if (type === 'line') {\n    contents = renderLine(sizeState.values, sizeState.bounds, scale, height, {\n      onClick: onClick,\n      onHover: onHover\n    });\n  } else if (type === 'area') {\n    contents = renderArea(sizeState.values, sizeState.bounds, scale, height, {\n      color: color,\n      onClick: onClick,\n      onHover: onHover,\n      theme: theme\n    });\n  }\n\n  return React.createElement(StyledChart, _extends({\n    ref: containerRef,\n    viewBox: viewBox,\n    preserveAspectRatio: \"none\",\n    width: size === 'full' ? '100%' : width,\n    height: size === 'full' ? '100%' : height\n  }, rest), React.createElement(\"g\", {\n    stroke: normalizeColor(colorName, theme),\n    strokeWidth: strokeWidth,\n    strokeLinecap: round ? 'round' : 'butt',\n    strokeLinejoin: round ? 'round' : 'miter',\n    opacity: opacity\n  }, contents));\n};\n\nvar ChartDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  ChartDoc = require('./doc').doc(Chart); // eslint-disable-line global-require\n}\n\nvar ChartWrapper = compose(withTheme)(ChartDoc || Chart);\nexport { ChartWrapper as Chart };","map":null,"metadata":{},"sourceType":"module"}